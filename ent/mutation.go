// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"wedding/ent/event"
	"wedding/ent/eventrsvp"
	"wedding/ent/invitee"
	"wedding/ent/inviteeparty"
	"wedding/ent/predicate"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeEvent        = "Event"
	TypeEventRSVP    = "EventRSVP"
	TypeInvitee      = "Invitee"
	TypeInviteeParty = "InviteeParty"
)

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	rsvps         map[int]struct{}
	removedrsvps  map[int]struct{}
	clearedrsvps  bool
	done          bool
	oldValue      func(context.Context) (*Event, error)
	predicates    []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id int) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *EventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *EventMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EventMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EventMutation) ResetName() {
	m.name = nil
}

// AddRsvpIDs adds the "rsvps" edge to the EventRSVP entity by ids.
func (m *EventMutation) AddRsvpIDs(ids ...int) {
	if m.rsvps == nil {
		m.rsvps = make(map[int]struct{})
	}
	for i := range ids {
		m.rsvps[ids[i]] = struct{}{}
	}
}

// ClearRsvps clears the "rsvps" edge to the EventRSVP entity.
func (m *EventMutation) ClearRsvps() {
	m.clearedrsvps = true
}

// RsvpsCleared reports if the "rsvps" edge to the EventRSVP entity was cleared.
func (m *EventMutation) RsvpsCleared() bool {
	return m.clearedrsvps
}

// RemoveRsvpIDs removes the "rsvps" edge to the EventRSVP entity by IDs.
func (m *EventMutation) RemoveRsvpIDs(ids ...int) {
	if m.removedrsvps == nil {
		m.removedrsvps = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrsvps[ids[i]] = struct{}{}
	}
}

// RemovedRsvps returns the removed IDs of the "rsvps" edge to the EventRSVP entity.
func (m *EventMutation) RemovedRsvpsIDs() (ids []int) {
	for id := range m.removedrsvps {
		ids = append(ids, id)
	}
	return
}

// RsvpsIDs returns the "rsvps" edge IDs in the mutation.
func (m *EventMutation) RsvpsIDs() (ids []int) {
	for id := range m.rsvps {
		ids = append(ids, id)
	}
	return
}

// ResetRsvps resets all changes to the "rsvps" edge.
func (m *EventMutation) ResetRsvps() {
	m.rsvps = nil
	m.clearedrsvps = false
	m.removedrsvps = nil
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, event.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.rsvps != nil {
		edges = append(edges, event.EdgeRsvps)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeRsvps:
		ids := make([]ent.Value, 0, len(m.rsvps))
		for id := range m.rsvps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrsvps != nil {
		edges = append(edges, event.EdgeRsvps)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeRsvps:
		ids := make([]ent.Value, 0, len(m.removedrsvps))
		for id := range m.removedrsvps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrsvps {
		edges = append(edges, event.EdgeRsvps)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeRsvps:
		return m.clearedrsvps
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeRsvps:
		m.ResetRsvps()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// EventRSVPMutation represents an operation that mutates the EventRSVP nodes in the graph.
type EventRSVPMutation struct {
	config
	op             Op
	typ            string
	id             *int
	clearedFields  map[string]struct{}
	event          *int
	clearedevent   bool
	invitee        *int
	clearedinvitee bool
	done           bool
	oldValue       func(context.Context) (*EventRSVP, error)
	predicates     []predicate.EventRSVP
}

var _ ent.Mutation = (*EventRSVPMutation)(nil)

// eventrsvpOption allows management of the mutation configuration using functional options.
type eventrsvpOption func(*EventRSVPMutation)

// newEventRSVPMutation creates new mutation for the EventRSVP entity.
func newEventRSVPMutation(c config, op Op, opts ...eventrsvpOption) *EventRSVPMutation {
	m := &EventRSVPMutation{
		config:        c,
		op:            op,
		typ:           TypeEventRSVP,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventRSVPID sets the ID field of the mutation.
func withEventRSVPID(id int) eventrsvpOption {
	return func(m *EventRSVPMutation) {
		var (
			err   error
			once  sync.Once
			value *EventRSVP
		)
		m.oldValue = func(ctx context.Context) (*EventRSVP, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventRSVP.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventRSVP sets the old EventRSVP of the mutation.
func withEventRSVP(node *EventRSVP) eventrsvpOption {
	return func(m *EventRSVPMutation) {
		m.oldValue = func(context.Context) (*EventRSVP, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventRSVPMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventRSVPMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *EventRSVPMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *EventRSVPMutation) SetEventID(id int) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *EventRSVPMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *EventRSVPMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *EventRSVPMutation) EventID() (id int, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *EventRSVPMutation) EventIDs() (ids []int) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *EventRSVPMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// SetInviteeID sets the "invitee" edge to the Invitee entity by id.
func (m *EventRSVPMutation) SetInviteeID(id int) {
	m.invitee = &id
}

// ClearInvitee clears the "invitee" edge to the Invitee entity.
func (m *EventRSVPMutation) ClearInvitee() {
	m.clearedinvitee = true
}

// InviteeCleared reports if the "invitee" edge to the Invitee entity was cleared.
func (m *EventRSVPMutation) InviteeCleared() bool {
	return m.clearedinvitee
}

// InviteeID returns the "invitee" edge ID in the mutation.
func (m *EventRSVPMutation) InviteeID() (id int, exists bool) {
	if m.invitee != nil {
		return *m.invitee, true
	}
	return
}

// InviteeIDs returns the "invitee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InviteeID instead. It exists only for internal usage by the builders.
func (m *EventRSVPMutation) InviteeIDs() (ids []int) {
	if id := m.invitee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvitee resets all changes to the "invitee" edge.
func (m *EventRSVPMutation) ResetInvitee() {
	m.invitee = nil
	m.clearedinvitee = false
}

// Op returns the operation name.
func (m *EventRSVPMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EventRSVP).
func (m *EventRSVPMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventRSVPMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventRSVPMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventRSVPMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown EventRSVP field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventRSVPMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EventRSVP field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventRSVPMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventRSVPMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventRSVPMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown EventRSVP numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventRSVPMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventRSVPMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventRSVPMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EventRSVP nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventRSVPMutation) ResetField(name string) error {
	return fmt.Errorf("unknown EventRSVP field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventRSVPMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.event != nil {
		edges = append(edges, eventrsvp.EdgeEvent)
	}
	if m.invitee != nil {
		edges = append(edges, eventrsvp.EdgeInvitee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventRSVPMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case eventrsvp.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	case eventrsvp.EdgeInvitee:
		if id := m.invitee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventRSVPMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventRSVPMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventRSVPMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedevent {
		edges = append(edges, eventrsvp.EdgeEvent)
	}
	if m.clearedinvitee {
		edges = append(edges, eventrsvp.EdgeInvitee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventRSVPMutation) EdgeCleared(name string) bool {
	switch name {
	case eventrsvp.EdgeEvent:
		return m.clearedevent
	case eventrsvp.EdgeInvitee:
		return m.clearedinvitee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventRSVPMutation) ClearEdge(name string) error {
	switch name {
	case eventrsvp.EdgeEvent:
		m.ClearEvent()
		return nil
	case eventrsvp.EdgeInvitee:
		m.ClearInvitee()
		return nil
	}
	return fmt.Errorf("unknown EventRSVP unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventRSVPMutation) ResetEdge(name string) error {
	switch name {
	case eventrsvp.EdgeEvent:
		m.ResetEvent()
		return nil
	case eventrsvp.EdgeInvitee:
		m.ResetInvitee()
		return nil
	}
	return fmt.Errorf("unknown EventRSVP edge %s", name)
}

// InviteeMutation represents an operation that mutates the Invitee nodes in the graph.
type InviteeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	is_child            *bool
	has_plus_one        *bool
	is_bridesmaid       *bool
	is_groomsman        *bool
	plus_one_name       *string
	phone               *string
	email               *string
	address_line_1      *string
	address_line_2      *string
	address_city        *string
	address_state       *string
	address_postal_code *string
	address_country     *string
	rsvp_response       *bool
	clearedFields       map[string]struct{}
	events              map[int]struct{}
	removedevents       map[int]struct{}
	clearedevents       bool
	party               *int
	clearedparty        bool
	done                bool
	oldValue            func(context.Context) (*Invitee, error)
	predicates          []predicate.Invitee
}

var _ ent.Mutation = (*InviteeMutation)(nil)

// inviteeOption allows management of the mutation configuration using functional options.
type inviteeOption func(*InviteeMutation)

// newInviteeMutation creates new mutation for the Invitee entity.
func newInviteeMutation(c config, op Op, opts ...inviteeOption) *InviteeMutation {
	m := &InviteeMutation{
		config:        c,
		op:            op,
		typ:           TypeInvitee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInviteeID sets the ID field of the mutation.
func withInviteeID(id int) inviteeOption {
	return func(m *InviteeMutation) {
		var (
			err   error
			once  sync.Once
			value *Invitee
		)
		m.oldValue = func(ctx context.Context) (*Invitee, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invitee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvitee sets the old Invitee of the mutation.
func withInvitee(node *Invitee) inviteeOption {
	return func(m *InviteeMutation) {
		m.oldValue = func(context.Context) (*Invitee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InviteeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InviteeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *InviteeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *InviteeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InviteeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Invitee entity.
// If the Invitee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *InviteeMutation) ResetName() {
	m.name = nil
}

// SetIsChild sets the "is_child" field.
func (m *InviteeMutation) SetIsChild(b bool) {
	m.is_child = &b
}

// IsChild returns the value of the "is_child" field in the mutation.
func (m *InviteeMutation) IsChild() (r bool, exists bool) {
	v := m.is_child
	if v == nil {
		return
	}
	return *v, true
}

// OldIsChild returns the old "is_child" field's value of the Invitee entity.
// If the Invitee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteeMutation) OldIsChild(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsChild is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsChild requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsChild: %w", err)
	}
	return oldValue.IsChild, nil
}

// ClearIsChild clears the value of the "is_child" field.
func (m *InviteeMutation) ClearIsChild() {
	m.is_child = nil
	m.clearedFields[invitee.FieldIsChild] = struct{}{}
}

// IsChildCleared returns if the "is_child" field was cleared in this mutation.
func (m *InviteeMutation) IsChildCleared() bool {
	_, ok := m.clearedFields[invitee.FieldIsChild]
	return ok
}

// ResetIsChild resets all changes to the "is_child" field.
func (m *InviteeMutation) ResetIsChild() {
	m.is_child = nil
	delete(m.clearedFields, invitee.FieldIsChild)
}

// SetHasPlusOne sets the "has_plus_one" field.
func (m *InviteeMutation) SetHasPlusOne(b bool) {
	m.has_plus_one = &b
}

// HasPlusOne returns the value of the "has_plus_one" field in the mutation.
func (m *InviteeMutation) HasPlusOne() (r bool, exists bool) {
	v := m.has_plus_one
	if v == nil {
		return
	}
	return *v, true
}

// OldHasPlusOne returns the old "has_plus_one" field's value of the Invitee entity.
// If the Invitee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteeMutation) OldHasPlusOne(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasPlusOne is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasPlusOne requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasPlusOne: %w", err)
	}
	return oldValue.HasPlusOne, nil
}

// ResetHasPlusOne resets all changes to the "has_plus_one" field.
func (m *InviteeMutation) ResetHasPlusOne() {
	m.has_plus_one = nil
}

// SetIsBridesmaid sets the "is_bridesmaid" field.
func (m *InviteeMutation) SetIsBridesmaid(b bool) {
	m.is_bridesmaid = &b
}

// IsBridesmaid returns the value of the "is_bridesmaid" field in the mutation.
func (m *InviteeMutation) IsBridesmaid() (r bool, exists bool) {
	v := m.is_bridesmaid
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBridesmaid returns the old "is_bridesmaid" field's value of the Invitee entity.
// If the Invitee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteeMutation) OldIsBridesmaid(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsBridesmaid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsBridesmaid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBridesmaid: %w", err)
	}
	return oldValue.IsBridesmaid, nil
}

// ResetIsBridesmaid resets all changes to the "is_bridesmaid" field.
func (m *InviteeMutation) ResetIsBridesmaid() {
	m.is_bridesmaid = nil
}

// SetIsGroomsman sets the "is_groomsman" field.
func (m *InviteeMutation) SetIsGroomsman(b bool) {
	m.is_groomsman = &b
}

// IsGroomsman returns the value of the "is_groomsman" field in the mutation.
func (m *InviteeMutation) IsGroomsman() (r bool, exists bool) {
	v := m.is_groomsman
	if v == nil {
		return
	}
	return *v, true
}

// OldIsGroomsman returns the old "is_groomsman" field's value of the Invitee entity.
// If the Invitee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteeMutation) OldIsGroomsman(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsGroomsman is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsGroomsman requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsGroomsman: %w", err)
	}
	return oldValue.IsGroomsman, nil
}

// ResetIsGroomsman resets all changes to the "is_groomsman" field.
func (m *InviteeMutation) ResetIsGroomsman() {
	m.is_groomsman = nil
}

// SetPlusOneName sets the "plus_one_name" field.
func (m *InviteeMutation) SetPlusOneName(s string) {
	m.plus_one_name = &s
}

// PlusOneName returns the value of the "plus_one_name" field in the mutation.
func (m *InviteeMutation) PlusOneName() (r string, exists bool) {
	v := m.plus_one_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPlusOneName returns the old "plus_one_name" field's value of the Invitee entity.
// If the Invitee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteeMutation) OldPlusOneName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPlusOneName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPlusOneName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlusOneName: %w", err)
	}
	return oldValue.PlusOneName, nil
}

// ClearPlusOneName clears the value of the "plus_one_name" field.
func (m *InviteeMutation) ClearPlusOneName() {
	m.plus_one_name = nil
	m.clearedFields[invitee.FieldPlusOneName] = struct{}{}
}

// PlusOneNameCleared returns if the "plus_one_name" field was cleared in this mutation.
func (m *InviteeMutation) PlusOneNameCleared() bool {
	_, ok := m.clearedFields[invitee.FieldPlusOneName]
	return ok
}

// ResetPlusOneName resets all changes to the "plus_one_name" field.
func (m *InviteeMutation) ResetPlusOneName() {
	m.plus_one_name = nil
	delete(m.clearedFields, invitee.FieldPlusOneName)
}

// SetPhone sets the "phone" field.
func (m *InviteeMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *InviteeMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Invitee entity.
// If the Invitee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteeMutation) OldPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *InviteeMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[invitee.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *InviteeMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[invitee.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *InviteeMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, invitee.FieldPhone)
}

// SetEmail sets the "email" field.
func (m *InviteeMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *InviteeMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Invitee entity.
// If the Invitee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteeMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *InviteeMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[invitee.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *InviteeMutation) EmailCleared() bool {
	_, ok := m.clearedFields[invitee.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *InviteeMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, invitee.FieldEmail)
}

// SetAddressLine1 sets the "address_line_1" field.
func (m *InviteeMutation) SetAddressLine1(s string) {
	m.address_line_1 = &s
}

// AddressLine1 returns the value of the "address_line_1" field in the mutation.
func (m *InviteeMutation) AddressLine1() (r string, exists bool) {
	v := m.address_line_1
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressLine1 returns the old "address_line_1" field's value of the Invitee entity.
// If the Invitee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteeMutation) OldAddressLine1(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddressLine1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddressLine1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressLine1: %w", err)
	}
	return oldValue.AddressLine1, nil
}

// ClearAddressLine1 clears the value of the "address_line_1" field.
func (m *InviteeMutation) ClearAddressLine1() {
	m.address_line_1 = nil
	m.clearedFields[invitee.FieldAddressLine1] = struct{}{}
}

// AddressLine1Cleared returns if the "address_line_1" field was cleared in this mutation.
func (m *InviteeMutation) AddressLine1Cleared() bool {
	_, ok := m.clearedFields[invitee.FieldAddressLine1]
	return ok
}

// ResetAddressLine1 resets all changes to the "address_line_1" field.
func (m *InviteeMutation) ResetAddressLine1() {
	m.address_line_1 = nil
	delete(m.clearedFields, invitee.FieldAddressLine1)
}

// SetAddressLine2 sets the "address_line_2" field.
func (m *InviteeMutation) SetAddressLine2(s string) {
	m.address_line_2 = &s
}

// AddressLine2 returns the value of the "address_line_2" field in the mutation.
func (m *InviteeMutation) AddressLine2() (r string, exists bool) {
	v := m.address_line_2
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressLine2 returns the old "address_line_2" field's value of the Invitee entity.
// If the Invitee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteeMutation) OldAddressLine2(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddressLine2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddressLine2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressLine2: %w", err)
	}
	return oldValue.AddressLine2, nil
}

// ClearAddressLine2 clears the value of the "address_line_2" field.
func (m *InviteeMutation) ClearAddressLine2() {
	m.address_line_2 = nil
	m.clearedFields[invitee.FieldAddressLine2] = struct{}{}
}

// AddressLine2Cleared returns if the "address_line_2" field was cleared in this mutation.
func (m *InviteeMutation) AddressLine2Cleared() bool {
	_, ok := m.clearedFields[invitee.FieldAddressLine2]
	return ok
}

// ResetAddressLine2 resets all changes to the "address_line_2" field.
func (m *InviteeMutation) ResetAddressLine2() {
	m.address_line_2 = nil
	delete(m.clearedFields, invitee.FieldAddressLine2)
}

// SetAddressCity sets the "address_city" field.
func (m *InviteeMutation) SetAddressCity(s string) {
	m.address_city = &s
}

// AddressCity returns the value of the "address_city" field in the mutation.
func (m *InviteeMutation) AddressCity() (r string, exists bool) {
	v := m.address_city
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressCity returns the old "address_city" field's value of the Invitee entity.
// If the Invitee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteeMutation) OldAddressCity(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddressCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddressCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressCity: %w", err)
	}
	return oldValue.AddressCity, nil
}

// ClearAddressCity clears the value of the "address_city" field.
func (m *InviteeMutation) ClearAddressCity() {
	m.address_city = nil
	m.clearedFields[invitee.FieldAddressCity] = struct{}{}
}

// AddressCityCleared returns if the "address_city" field was cleared in this mutation.
func (m *InviteeMutation) AddressCityCleared() bool {
	_, ok := m.clearedFields[invitee.FieldAddressCity]
	return ok
}

// ResetAddressCity resets all changes to the "address_city" field.
func (m *InviteeMutation) ResetAddressCity() {
	m.address_city = nil
	delete(m.clearedFields, invitee.FieldAddressCity)
}

// SetAddressState sets the "address_state" field.
func (m *InviteeMutation) SetAddressState(s string) {
	m.address_state = &s
}

// AddressState returns the value of the "address_state" field in the mutation.
func (m *InviteeMutation) AddressState() (r string, exists bool) {
	v := m.address_state
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressState returns the old "address_state" field's value of the Invitee entity.
// If the Invitee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteeMutation) OldAddressState(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddressState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddressState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressState: %w", err)
	}
	return oldValue.AddressState, nil
}

// ClearAddressState clears the value of the "address_state" field.
func (m *InviteeMutation) ClearAddressState() {
	m.address_state = nil
	m.clearedFields[invitee.FieldAddressState] = struct{}{}
}

// AddressStateCleared returns if the "address_state" field was cleared in this mutation.
func (m *InviteeMutation) AddressStateCleared() bool {
	_, ok := m.clearedFields[invitee.FieldAddressState]
	return ok
}

// ResetAddressState resets all changes to the "address_state" field.
func (m *InviteeMutation) ResetAddressState() {
	m.address_state = nil
	delete(m.clearedFields, invitee.FieldAddressState)
}

// SetAddressPostalCode sets the "address_postal_code" field.
func (m *InviteeMutation) SetAddressPostalCode(s string) {
	m.address_postal_code = &s
}

// AddressPostalCode returns the value of the "address_postal_code" field in the mutation.
func (m *InviteeMutation) AddressPostalCode() (r string, exists bool) {
	v := m.address_postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressPostalCode returns the old "address_postal_code" field's value of the Invitee entity.
// If the Invitee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteeMutation) OldAddressPostalCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddressPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddressPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressPostalCode: %w", err)
	}
	return oldValue.AddressPostalCode, nil
}

// ClearAddressPostalCode clears the value of the "address_postal_code" field.
func (m *InviteeMutation) ClearAddressPostalCode() {
	m.address_postal_code = nil
	m.clearedFields[invitee.FieldAddressPostalCode] = struct{}{}
}

// AddressPostalCodeCleared returns if the "address_postal_code" field was cleared in this mutation.
func (m *InviteeMutation) AddressPostalCodeCleared() bool {
	_, ok := m.clearedFields[invitee.FieldAddressPostalCode]
	return ok
}

// ResetAddressPostalCode resets all changes to the "address_postal_code" field.
func (m *InviteeMutation) ResetAddressPostalCode() {
	m.address_postal_code = nil
	delete(m.clearedFields, invitee.FieldAddressPostalCode)
}

// SetAddressCountry sets the "address_country" field.
func (m *InviteeMutation) SetAddressCountry(s string) {
	m.address_country = &s
}

// AddressCountry returns the value of the "address_country" field in the mutation.
func (m *InviteeMutation) AddressCountry() (r string, exists bool) {
	v := m.address_country
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressCountry returns the old "address_country" field's value of the Invitee entity.
// If the Invitee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteeMutation) OldAddressCountry(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddressCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddressCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressCountry: %w", err)
	}
	return oldValue.AddressCountry, nil
}

// ClearAddressCountry clears the value of the "address_country" field.
func (m *InviteeMutation) ClearAddressCountry() {
	m.address_country = nil
	m.clearedFields[invitee.FieldAddressCountry] = struct{}{}
}

// AddressCountryCleared returns if the "address_country" field was cleared in this mutation.
func (m *InviteeMutation) AddressCountryCleared() bool {
	_, ok := m.clearedFields[invitee.FieldAddressCountry]
	return ok
}

// ResetAddressCountry resets all changes to the "address_country" field.
func (m *InviteeMutation) ResetAddressCountry() {
	m.address_country = nil
	delete(m.clearedFields, invitee.FieldAddressCountry)
}

// SetRsvpResponse sets the "rsvp_response" field.
func (m *InviteeMutation) SetRsvpResponse(b bool) {
	m.rsvp_response = &b
}

// RsvpResponse returns the value of the "rsvp_response" field in the mutation.
func (m *InviteeMutation) RsvpResponse() (r bool, exists bool) {
	v := m.rsvp_response
	if v == nil {
		return
	}
	return *v, true
}

// OldRsvpResponse returns the old "rsvp_response" field's value of the Invitee entity.
// If the Invitee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteeMutation) OldRsvpResponse(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRsvpResponse is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRsvpResponse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRsvpResponse: %w", err)
	}
	return oldValue.RsvpResponse, nil
}

// ClearRsvpResponse clears the value of the "rsvp_response" field.
func (m *InviteeMutation) ClearRsvpResponse() {
	m.rsvp_response = nil
	m.clearedFields[invitee.FieldRsvpResponse] = struct{}{}
}

// RsvpResponseCleared returns if the "rsvp_response" field was cleared in this mutation.
func (m *InviteeMutation) RsvpResponseCleared() bool {
	_, ok := m.clearedFields[invitee.FieldRsvpResponse]
	return ok
}

// ResetRsvpResponse resets all changes to the "rsvp_response" field.
func (m *InviteeMutation) ResetRsvpResponse() {
	m.rsvp_response = nil
	delete(m.clearedFields, invitee.FieldRsvpResponse)
}

// AddEventIDs adds the "events" edge to the EventRSVP entity by ids.
func (m *InviteeMutation) AddEventIDs(ids ...int) {
	if m.events == nil {
		m.events = make(map[int]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the EventRSVP entity.
func (m *InviteeMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the EventRSVP entity was cleared.
func (m *InviteeMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the EventRSVP entity by IDs.
func (m *InviteeMutation) RemoveEventIDs(ids ...int) {
	if m.removedevents == nil {
		m.removedevents = make(map[int]struct{})
	}
	for i := range ids {
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the EventRSVP entity.
func (m *InviteeMutation) RemovedEventsIDs() (ids []int) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *InviteeMutation) EventsIDs() (ids []int) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *InviteeMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// SetPartyID sets the "party" edge to the InviteeParty entity by id.
func (m *InviteeMutation) SetPartyID(id int) {
	m.party = &id
}

// ClearParty clears the "party" edge to the InviteeParty entity.
func (m *InviteeMutation) ClearParty() {
	m.clearedparty = true
}

// PartyCleared reports if the "party" edge to the InviteeParty entity was cleared.
func (m *InviteeMutation) PartyCleared() bool {
	return m.clearedparty
}

// PartyID returns the "party" edge ID in the mutation.
func (m *InviteeMutation) PartyID() (id int, exists bool) {
	if m.party != nil {
		return *m.party, true
	}
	return
}

// PartyIDs returns the "party" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartyID instead. It exists only for internal usage by the builders.
func (m *InviteeMutation) PartyIDs() (ids []int) {
	if id := m.party; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParty resets all changes to the "party" edge.
func (m *InviteeMutation) ResetParty() {
	m.party = nil
	m.clearedparty = false
}

// Op returns the operation name.
func (m *InviteeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Invitee).
func (m *InviteeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InviteeMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.name != nil {
		fields = append(fields, invitee.FieldName)
	}
	if m.is_child != nil {
		fields = append(fields, invitee.FieldIsChild)
	}
	if m.has_plus_one != nil {
		fields = append(fields, invitee.FieldHasPlusOne)
	}
	if m.is_bridesmaid != nil {
		fields = append(fields, invitee.FieldIsBridesmaid)
	}
	if m.is_groomsman != nil {
		fields = append(fields, invitee.FieldIsGroomsman)
	}
	if m.plus_one_name != nil {
		fields = append(fields, invitee.FieldPlusOneName)
	}
	if m.phone != nil {
		fields = append(fields, invitee.FieldPhone)
	}
	if m.email != nil {
		fields = append(fields, invitee.FieldEmail)
	}
	if m.address_line_1 != nil {
		fields = append(fields, invitee.FieldAddressLine1)
	}
	if m.address_line_2 != nil {
		fields = append(fields, invitee.FieldAddressLine2)
	}
	if m.address_city != nil {
		fields = append(fields, invitee.FieldAddressCity)
	}
	if m.address_state != nil {
		fields = append(fields, invitee.FieldAddressState)
	}
	if m.address_postal_code != nil {
		fields = append(fields, invitee.FieldAddressPostalCode)
	}
	if m.address_country != nil {
		fields = append(fields, invitee.FieldAddressCountry)
	}
	if m.rsvp_response != nil {
		fields = append(fields, invitee.FieldRsvpResponse)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InviteeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invitee.FieldName:
		return m.Name()
	case invitee.FieldIsChild:
		return m.IsChild()
	case invitee.FieldHasPlusOne:
		return m.HasPlusOne()
	case invitee.FieldIsBridesmaid:
		return m.IsBridesmaid()
	case invitee.FieldIsGroomsman:
		return m.IsGroomsman()
	case invitee.FieldPlusOneName:
		return m.PlusOneName()
	case invitee.FieldPhone:
		return m.Phone()
	case invitee.FieldEmail:
		return m.Email()
	case invitee.FieldAddressLine1:
		return m.AddressLine1()
	case invitee.FieldAddressLine2:
		return m.AddressLine2()
	case invitee.FieldAddressCity:
		return m.AddressCity()
	case invitee.FieldAddressState:
		return m.AddressState()
	case invitee.FieldAddressPostalCode:
		return m.AddressPostalCode()
	case invitee.FieldAddressCountry:
		return m.AddressCountry()
	case invitee.FieldRsvpResponse:
		return m.RsvpResponse()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InviteeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invitee.FieldName:
		return m.OldName(ctx)
	case invitee.FieldIsChild:
		return m.OldIsChild(ctx)
	case invitee.FieldHasPlusOne:
		return m.OldHasPlusOne(ctx)
	case invitee.FieldIsBridesmaid:
		return m.OldIsBridesmaid(ctx)
	case invitee.FieldIsGroomsman:
		return m.OldIsGroomsman(ctx)
	case invitee.FieldPlusOneName:
		return m.OldPlusOneName(ctx)
	case invitee.FieldPhone:
		return m.OldPhone(ctx)
	case invitee.FieldEmail:
		return m.OldEmail(ctx)
	case invitee.FieldAddressLine1:
		return m.OldAddressLine1(ctx)
	case invitee.FieldAddressLine2:
		return m.OldAddressLine2(ctx)
	case invitee.FieldAddressCity:
		return m.OldAddressCity(ctx)
	case invitee.FieldAddressState:
		return m.OldAddressState(ctx)
	case invitee.FieldAddressPostalCode:
		return m.OldAddressPostalCode(ctx)
	case invitee.FieldAddressCountry:
		return m.OldAddressCountry(ctx)
	case invitee.FieldRsvpResponse:
		return m.OldRsvpResponse(ctx)
	}
	return nil, fmt.Errorf("unknown Invitee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InviteeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invitee.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case invitee.FieldIsChild:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsChild(v)
		return nil
	case invitee.FieldHasPlusOne:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasPlusOne(v)
		return nil
	case invitee.FieldIsBridesmaid:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBridesmaid(v)
		return nil
	case invitee.FieldIsGroomsman:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsGroomsman(v)
		return nil
	case invitee.FieldPlusOneName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlusOneName(v)
		return nil
	case invitee.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case invitee.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case invitee.FieldAddressLine1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressLine1(v)
		return nil
	case invitee.FieldAddressLine2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressLine2(v)
		return nil
	case invitee.FieldAddressCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressCity(v)
		return nil
	case invitee.FieldAddressState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressState(v)
		return nil
	case invitee.FieldAddressPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressPostalCode(v)
		return nil
	case invitee.FieldAddressCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressCountry(v)
		return nil
	case invitee.FieldRsvpResponse:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRsvpResponse(v)
		return nil
	}
	return fmt.Errorf("unknown Invitee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InviteeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InviteeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InviteeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Invitee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InviteeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invitee.FieldIsChild) {
		fields = append(fields, invitee.FieldIsChild)
	}
	if m.FieldCleared(invitee.FieldPlusOneName) {
		fields = append(fields, invitee.FieldPlusOneName)
	}
	if m.FieldCleared(invitee.FieldPhone) {
		fields = append(fields, invitee.FieldPhone)
	}
	if m.FieldCleared(invitee.FieldEmail) {
		fields = append(fields, invitee.FieldEmail)
	}
	if m.FieldCleared(invitee.FieldAddressLine1) {
		fields = append(fields, invitee.FieldAddressLine1)
	}
	if m.FieldCleared(invitee.FieldAddressLine2) {
		fields = append(fields, invitee.FieldAddressLine2)
	}
	if m.FieldCleared(invitee.FieldAddressCity) {
		fields = append(fields, invitee.FieldAddressCity)
	}
	if m.FieldCleared(invitee.FieldAddressState) {
		fields = append(fields, invitee.FieldAddressState)
	}
	if m.FieldCleared(invitee.FieldAddressPostalCode) {
		fields = append(fields, invitee.FieldAddressPostalCode)
	}
	if m.FieldCleared(invitee.FieldAddressCountry) {
		fields = append(fields, invitee.FieldAddressCountry)
	}
	if m.FieldCleared(invitee.FieldRsvpResponse) {
		fields = append(fields, invitee.FieldRsvpResponse)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InviteeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InviteeMutation) ClearField(name string) error {
	switch name {
	case invitee.FieldIsChild:
		m.ClearIsChild()
		return nil
	case invitee.FieldPlusOneName:
		m.ClearPlusOneName()
		return nil
	case invitee.FieldPhone:
		m.ClearPhone()
		return nil
	case invitee.FieldEmail:
		m.ClearEmail()
		return nil
	case invitee.FieldAddressLine1:
		m.ClearAddressLine1()
		return nil
	case invitee.FieldAddressLine2:
		m.ClearAddressLine2()
		return nil
	case invitee.FieldAddressCity:
		m.ClearAddressCity()
		return nil
	case invitee.FieldAddressState:
		m.ClearAddressState()
		return nil
	case invitee.FieldAddressPostalCode:
		m.ClearAddressPostalCode()
		return nil
	case invitee.FieldAddressCountry:
		m.ClearAddressCountry()
		return nil
	case invitee.FieldRsvpResponse:
		m.ClearRsvpResponse()
		return nil
	}
	return fmt.Errorf("unknown Invitee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InviteeMutation) ResetField(name string) error {
	switch name {
	case invitee.FieldName:
		m.ResetName()
		return nil
	case invitee.FieldIsChild:
		m.ResetIsChild()
		return nil
	case invitee.FieldHasPlusOne:
		m.ResetHasPlusOne()
		return nil
	case invitee.FieldIsBridesmaid:
		m.ResetIsBridesmaid()
		return nil
	case invitee.FieldIsGroomsman:
		m.ResetIsGroomsman()
		return nil
	case invitee.FieldPlusOneName:
		m.ResetPlusOneName()
		return nil
	case invitee.FieldPhone:
		m.ResetPhone()
		return nil
	case invitee.FieldEmail:
		m.ResetEmail()
		return nil
	case invitee.FieldAddressLine1:
		m.ResetAddressLine1()
		return nil
	case invitee.FieldAddressLine2:
		m.ResetAddressLine2()
		return nil
	case invitee.FieldAddressCity:
		m.ResetAddressCity()
		return nil
	case invitee.FieldAddressState:
		m.ResetAddressState()
		return nil
	case invitee.FieldAddressPostalCode:
		m.ResetAddressPostalCode()
		return nil
	case invitee.FieldAddressCountry:
		m.ResetAddressCountry()
		return nil
	case invitee.FieldRsvpResponse:
		m.ResetRsvpResponse()
		return nil
	}
	return fmt.Errorf("unknown Invitee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InviteeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.events != nil {
		edges = append(edges, invitee.EdgeEvents)
	}
	if m.party != nil {
		edges = append(edges, invitee.EdgeParty)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InviteeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invitee.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case invitee.EdgeParty:
		if id := m.party; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InviteeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedevents != nil {
		edges = append(edges, invitee.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InviteeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case invitee.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InviteeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedevents {
		edges = append(edges, invitee.EdgeEvents)
	}
	if m.clearedparty {
		edges = append(edges, invitee.EdgeParty)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InviteeMutation) EdgeCleared(name string) bool {
	switch name {
	case invitee.EdgeEvents:
		return m.clearedevents
	case invitee.EdgeParty:
		return m.clearedparty
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InviteeMutation) ClearEdge(name string) error {
	switch name {
	case invitee.EdgeParty:
		m.ClearParty()
		return nil
	}
	return fmt.Errorf("unknown Invitee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InviteeMutation) ResetEdge(name string) error {
	switch name {
	case invitee.EdgeEvents:
		m.ResetEvents()
		return nil
	case invitee.EdgeParty:
		m.ResetParty()
		return nil
	}
	return fmt.Errorf("unknown Invitee edge %s", name)
}

// InviteePartyMutation represents an operation that mutates the InviteeParty nodes in the graph.
type InviteePartyMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	code            *string
	clearedFields   map[string]struct{}
	invitees        map[int]struct{}
	removedinvitees map[int]struct{}
	clearedinvitees bool
	done            bool
	oldValue        func(context.Context) (*InviteeParty, error)
	predicates      []predicate.InviteeParty
}

var _ ent.Mutation = (*InviteePartyMutation)(nil)

// inviteepartyOption allows management of the mutation configuration using functional options.
type inviteepartyOption func(*InviteePartyMutation)

// newInviteePartyMutation creates new mutation for the InviteeParty entity.
func newInviteePartyMutation(c config, op Op, opts ...inviteepartyOption) *InviteePartyMutation {
	m := &InviteePartyMutation{
		config:        c,
		op:            op,
		typ:           TypeInviteeParty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInviteePartyID sets the ID field of the mutation.
func withInviteePartyID(id int) inviteepartyOption {
	return func(m *InviteePartyMutation) {
		var (
			err   error
			once  sync.Once
			value *InviteeParty
		)
		m.oldValue = func(ctx context.Context) (*InviteeParty, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InviteeParty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInviteeParty sets the old InviteeParty of the mutation.
func withInviteeParty(node *InviteeParty) inviteepartyOption {
	return func(m *InviteePartyMutation) {
		m.oldValue = func(context.Context) (*InviteeParty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InviteePartyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InviteePartyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *InviteePartyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *InviteePartyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InviteePartyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the InviteeParty entity.
// If the InviteeParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteePartyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *InviteePartyMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *InviteePartyMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *InviteePartyMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the InviteeParty entity.
// If the InviteeParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteePartyMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *InviteePartyMutation) ResetCode() {
	m.code = nil
}

// AddInviteeIDs adds the "invitees" edge to the Invitee entity by ids.
func (m *InviteePartyMutation) AddInviteeIDs(ids ...int) {
	if m.invitees == nil {
		m.invitees = make(map[int]struct{})
	}
	for i := range ids {
		m.invitees[ids[i]] = struct{}{}
	}
}

// ClearInvitees clears the "invitees" edge to the Invitee entity.
func (m *InviteePartyMutation) ClearInvitees() {
	m.clearedinvitees = true
}

// InviteesCleared reports if the "invitees" edge to the Invitee entity was cleared.
func (m *InviteePartyMutation) InviteesCleared() bool {
	return m.clearedinvitees
}

// RemoveInviteeIDs removes the "invitees" edge to the Invitee entity by IDs.
func (m *InviteePartyMutation) RemoveInviteeIDs(ids ...int) {
	if m.removedinvitees == nil {
		m.removedinvitees = make(map[int]struct{})
	}
	for i := range ids {
		m.removedinvitees[ids[i]] = struct{}{}
	}
}

// RemovedInvitees returns the removed IDs of the "invitees" edge to the Invitee entity.
func (m *InviteePartyMutation) RemovedInviteesIDs() (ids []int) {
	for id := range m.removedinvitees {
		ids = append(ids, id)
	}
	return
}

// InviteesIDs returns the "invitees" edge IDs in the mutation.
func (m *InviteePartyMutation) InviteesIDs() (ids []int) {
	for id := range m.invitees {
		ids = append(ids, id)
	}
	return
}

// ResetInvitees resets all changes to the "invitees" edge.
func (m *InviteePartyMutation) ResetInvitees() {
	m.invitees = nil
	m.clearedinvitees = false
	m.removedinvitees = nil
}

// Op returns the operation name.
func (m *InviteePartyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InviteeParty).
func (m *InviteePartyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InviteePartyMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, inviteeparty.FieldName)
	}
	if m.code != nil {
		fields = append(fields, inviteeparty.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InviteePartyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inviteeparty.FieldName:
		return m.Name()
	case inviteeparty.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InviteePartyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inviteeparty.FieldName:
		return m.OldName(ctx)
	case inviteeparty.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown InviteeParty field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InviteePartyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inviteeparty.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case inviteeparty.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown InviteeParty field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InviteePartyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InviteePartyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InviteePartyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InviteeParty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InviteePartyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InviteePartyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InviteePartyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InviteeParty nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InviteePartyMutation) ResetField(name string) error {
	switch name {
	case inviteeparty.FieldName:
		m.ResetName()
		return nil
	case inviteeparty.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown InviteeParty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InviteePartyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.invitees != nil {
		edges = append(edges, inviteeparty.EdgeInvitees)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InviteePartyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inviteeparty.EdgeInvitees:
		ids := make([]ent.Value, 0, len(m.invitees))
		for id := range m.invitees {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InviteePartyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedinvitees != nil {
		edges = append(edges, inviteeparty.EdgeInvitees)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InviteePartyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case inviteeparty.EdgeInvitees:
		ids := make([]ent.Value, 0, len(m.removedinvitees))
		for id := range m.removedinvitees {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InviteePartyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedinvitees {
		edges = append(edges, inviteeparty.EdgeInvitees)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InviteePartyMutation) EdgeCleared(name string) bool {
	switch name {
	case inviteeparty.EdgeInvitees:
		return m.clearedinvitees
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InviteePartyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown InviteeParty unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InviteePartyMutation) ResetEdge(name string) error {
	switch name {
	case inviteeparty.EdgeInvitees:
		m.ResetInvitees()
		return nil
	}
	return fmt.Errorf("unknown InviteeParty edge %s", name)
}
